<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>LSP still testing</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="551" height="551"></canvas>

<script> {

    //make a canvas
    var canvas = document.getElementById("myCanvas");
    var ctx =  canvas.getContext("2d");

    //board dimensions
    var bs = 25; //box size
    var bh = 500; //board height
    var bw = 500; //board width
    var p = 0.5 //padding
    const columns = Math.floor(bw / bs);
    const rows = Math.floor(bh / bs);
    var gridX = 26
    var gridY = 26
    var ug = [] //unit snap-to grid at box centers
    for (var c = 0; c < columns; c++) {
        ug[c] = [];
        for(var r = 0; r < rows; r++) {
            ug[c][r] = {x: 0, y: 0, status: "empty"}
        }
    }

    //how to draw the stuff

    function drawGrid(){
        for (var x = p; x <= bw+p; x+= bs) {
            ctx.beginPath();
            ctx.moveTo(x,0);
            var every5th = (x % (bs*5)-p)
            if (every5th == 0){
                ctx.lineWidth = 2
            } else {
                ctx.lineWidth = 1
            }
            ctx.lineTo(x, bh);
            ctx.stroke();
        }
        for (var y = p; y <= bh+p; y+= bs) {
            ctx.beginPath();
            ctx.moveTo(0,y);
            var every5th = (y % (bs*5)-p)
            if (every5th == 0){
                ctx.lineWidth = 2
            } else {
                ctx.lineWidth = 1
            }
            ctx.lineTo(bw, y);
            ctx.stroke();
        }
    }
    function drawBall(gridX, gridY, color) {
        ctx.beginPath();
        ctx.arc(gridX, gridY, 10, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
    }
    function drawSpawn(gridX, gridY) {
        ctx.beginPath();
        ctx.rect(gridX - bs/2, gridY - bs/2, bs-p, bs-p);
        ctx.fillStyle = "green";
        ctx.fill();
        ctx.closePath();
        /*

        */
    }


    ug[7][17].status = "spawnB";
    ug[13][3].status = "spawnR";

    function drawUnits() {
        for(var c=0; c<columns; c++) {
            for(var r=0; r<rows; r++) {
                var gridX = ((c*bs) + p +(bs/2));
                var gridY = ((r*bs) + p +(bs/2));
                ug[c][r].x = gridX;
                ug[c][r].y = gridY;
                if (ug[c][r].status === "spawnB") {
                    var color = "blue"
                    drawSpawn(gridX, gridY)
                    ug[c][r+1].status = color;
                    ug[c][r-1].status = color;
                    ug[c+1][r].status = color;
                    ug[c-1][r].status = color;
                } else if (ug[c][r].status === "blue"){
                    drawBall(gridX, gridY, "blue");
                } else if (ug[c][r].status === "red") {
                    drawBall(gridX, gridY, "red");
                } else {
                    ctx.beginPath();
                    ctx.rect(gridX,gridY,1,1);
                    ctx.fillStyle = "black"
                    ctx.fill();
                    ctx.closePath;
                }
            }
        }
    }

//=============================================//
//key
//-//<-- necessaray for minimum viable product
//.  <-- "nice to have"s
//:) <-- done enough
//=============================================//
    //-//:)game board
        //:)make a grid
                //.make variable maps with impassable terrain
    //-//starting locations
        //-//spawner (at first can spawn in front every turn)
        //-//spawner dies if central diamond shape is broken by bomber
        //-//spawner dies if completely surrounded
                //.spawner lights up green in the middle
                //.green part works as a button
                //.button attaches a new guy of your color to your mouse
                //.having a guy attached shows a spawn radius
                //.clicking in the radius assigns the new guy to the closest unoccupied box
    //-//troops
        //-//red and blue
        //-//select and move them by dragging
        //-//3~5 moves per turn
        //-//cannot occupy the same space
        //-//if one group surrounds an enemy group on 4 sides, the surrounded one dies
        //-//single troops can suicide bomb
                //.assign locked in formations by shift+click then "lock"
                //.be able to break formations by click "unlock"
                //.create formation troop separation limits
                //.create formation attributes
                //.formations move together but have reduced speed, 
                        //which makes them faster than if the single units moved individually
                //.formations can push and warp the shape of enemy units/formations
                        //at a hight cost to movement
                //.create "create spawnpoint" option for diamond formation
                //.create "create fortification" option for any formation with gaps =< 1,
                        //which prevents movement but bridges gaps
                //.single units can move diagonally
                //.troops can be stationed on friendly fortifications
                //.troops can not suicide bomb manned fortifications
            //.HUD
                //.who's turn
                //.number of moves left
            //.online multiplayer
            //.optimization
                //.update only on user input




//====Draw all of the components together

    function draw() {

        //wipe between frames
        ctx.clearRect(0 ,0, canvas.width, canvas.height);

        drawGrid();
        drawBall();
        drawUnits();

    }
    

    //framerate || gamespeed
    var frameRate = 1000;
    var interval = setInterval(draw, frameRate);
}
</script>

</body>
</html>